---
title: "Лабораторная работа №9. Понятие подпрограммы. Отладчик GDB"
author: "[Сунь Шэнцзе]"
date: "06.12.2025"
format:
  pdf:
    documentclass: article
    mainfont: "DejaVu Serif"
    sansfont: "DejaVu Sans"
    monofont: "DejaVu Sans Mono"
    latex-engine: xelatex
    lang: ru
---

idnumber: "1132254527"

## 1. Цель работы
- Приобретение навыков написания программ с использованием подпрограмм
- Освоение методов отладки с помощью отладчика GDB
- Изучение основных команд отладчика GDB
- Освоение установки точек останова и пошагового выполнения
- Изучение работы с данными программы в отладчике

## 2. Порядок выполнения работы и результаты

### 2.1 Шаг 1: Создание рабочего каталога
![Создание каталога](screenshots/1.png)
*   **Основное:** Успешное создание каталога для лабораторной работы `cd ~/work/study/2025-2026/архитектура\ компьютера/arch-pc/labs/lab09` и переход в него, подготовка к выполнению заданий по подпрограммам.

### 2.2 Шаг 2: Создание файла Lab9-1.asm с базовой подпрограммой
![Создание файла](screenshots/1.png)
*   **Основное:** Создание файла `lab9-1.asm` с программой вычисления выражения f(x) = 2x + 7 с использованием подпрограммы `_calcul`.

### 2.3 Шаг 3: Написание кода программы с подпрограммой
![Исходный код](screenshots/2.png)
![Исходный код](screenshots/3.png)
*   **Основное:** Ввод в `lab9-1.asm` программы с использованием подпрограммы `_calcul`, содержащей инструкции `call` и `ret` для организации вызова и возврата из подпрограммы.

### 2.4 Шаг 4: Компиляция и запуск программы с подпрограммой
![Результат первого запуска](screenshots/4.png)
*   **Основное:** Успешная компиляция и запуск программы, вывод показывает корректное вычисление выражения 2x+7, подтверждает правильную работу подпрограммы.

### 2.5 Шаг 5: Модификация программы с вложенной подпрограммой
![Модифицированный код](screenshots/5.png)
![Модифицированный код](screenshots/6.png)
*   **Основное:** Модификация программы с добавлением вложенной подпрограммы `_subcalcul` для вычисления f(g(x)), где g(x) = 3x - 1.

### 2.6 Шаг 6: Запуск модифицированной программы
![Результат модифицированного запуска](screenshots/7.png)
*   **Основное:** Успешный запуск модифицированной программы, вывод показывает корректное вычисление сложного выражения f(g(x)) = 2*(3x-1)+7.

### 2.7 Шаг 7: Создание файла Lab09-2.asm для отладки
![Создание lab09-2](screenshots/9.png)
*   **Основное:** Создание файла `lab9-2.asm` с программой "Hello, world!" для освоения работы с отладчиком GDB.

### 2.8 Шаг 8: Компиляция с отладочной информацией
![Компиляция с -g](screenshots/8.png)
*   **Основное:** Компиляция программы с ключом `-g` для включения отладочной информации, необходимая для работы с GDB.

### 2.9 Шаг 9: Запуск программы в GDB
![Запуск в GDB](screenshots/10.png)
*   **Основное:** Успешный запуск программы в оболочке GDB, программа корректно выводит "Hello, world!".

### 2.10 Шаг 10: Установка точек останова и анализ кода
![Точки останова](screenshots/11.png)
*   **Основное:** Установка точки останова на метке `_start` и анализ дизассемблированного кода программы.

### 2.11 Шаг 11: Сравнение синтаксисов ATT и Intel
![Синтаксисы ATT и Intel](screenshots/11.png)
![Синтаксисы ATT и Intel](screenshots/12.png)
*   **Основное:** Переключение между синтаксисами ATT и Intel, демонстрация различий в порядке операндов и формате команд.

### 2.12 Шаг 12: Работа в режиме TUI
![Режим TUI](screenshots/13.png)
*   **Основное:** Включение режима псевдографики TUI с отображением регистров, ассемблерного кода и командной строки.

### 2.13 Шаг 13: Управление точками останова
![Управление breakpoints](screenshots/14.png)
*   **Основное:** Установка дополнительных точек останова по адресу инструкции и управление ими с помощью команд `info breakpoints`.

### 2.14 Шаг 14: Пошаговое выполнение и анализ регистров
![Анализ регистров](screenshots/15.png)
*   **Основное:** Пошаговое выполнение программы командой `stepi` и отслеживание изменений значений регистров.

### 2.15 Шаг 15: Работа с памятью и переменными
![Работа с памятью](screenshots/16.png)
*   **Основное:** Просмотр содержимого переменных `msg1` и `msg2` в памяти с помощью команды `x/sb`.

### 2.16 Шаг 16: Модификация данных в памяти
![Модификация данных](screenshots/17.png)
![Модификация данных](screenshots/18.png)
*   **Основное:** Изменение содержимого переменных в памяти с помощью команды `set` и проверка результатов.

### 2.17 Шаг 17: Работа с регистрами
![Работа с регистрами](screenshots/20.png)
*   **Основное:** Изменение значений регистров и их отображение в различных форматах (шестнадцатеричном, двоичном, символьном).

### 2.18 Шаг 18: Анализ аргументов командной строки
![Аргументы командной строки](screenshots/24.png)
*   **Основное:** Загрузка программы с аргументами командной строки и анализ их расположения в стеке.

### 2.19 Шаг 19: Исследование стека аргументов
![Исследование стека](screenshots/25.png)
*   **Основное:** Просмотр аргументов командной строки в стеке с шагом 4 байта, соответствующем размеру указателя в 32-битной системе.

## 3. Выполнение заданий для самостоятельной работы

### 3.1 Задание 1: Преобразование программы Lab08 с использованием подпрограмм
![Код преобразованной программы](screenshots/26.png)
![Код преобразованной программы](screenshots/27.png)
![Код преобразованной программы](screenshots/28.png)
![Код преобразованной программы](screenshots/29.png)
![Код преобразованной программы](screenshots/30.png)
![Код преобразованной программы](screenshots/31.png)
*   **Вывод:** Успешное преобразование программы из лабораторной работы №8, вычисление значения функции реализовано как подпрограмма, программа работает корректно.

### 3.2 Задание 2: Отладка и исправление ошибочной программы
![Ошибочная программа](screenshots/32.png)
![Ошибочная программа](screenshots/33.png)
*   **Вывод:** Обнаружение ошибки в программе вычисления выражения (3+2)*4+5 с помощью отладчика GDB.

### 3.3 Шаг отладки: Анализ ошибки в GDB
![Анализ ошибки в GDB](screenshots/34.png)
![Анализ ошибки в GDB](screenshots/35.png)
*   **Вывод:** С помощью пошагового выполнения в GDB обнаружено, что инструкция `mul ecx` неправильно использует регистр EAX, разрушая промежуточный результат.

### 3.4 Исправленная программа
![Исправленная программа](screenshots/36.png)
*   **Вывод:** Ошибка исправлена путем переупорядочивания инструкций, программа теперь выдает правильный результат 25.

### 3.5 Результат исправленной программы
![Результат исправленной программы](screenshots/17.png)
*   **Вывод:** Исправленная программа успешно вычисляет выражение (3+2)*4+5 = 25 и выводит корректный результат.

## 4. Ответы на вопросы для самопроверки

1. **Какие языковые средства используются в ассемблере для оформления и активизации подпрограмм?**  
   Для оформления подпрограмм используются метки, а для активизации - инструкции `call` и `ret`. Инструкция `call` сохраняет адрес возврата в стеке и передает управление подпрограмме, а `ret` извлекает адрес возврата из стека и возвращает управление.

2. **Объясните механизм вызова подпрограмм.**  
   При вызове подпрограммы инструкция `call` выполняет две операции: сохраняет адрес следующей инструкции (адрес возврата) в стеке и загружает адрес подпрограммы в регистр EIP. При возврате инструкция `ret` извлекает адрес возврата из стека и загружает его в EIP.

3. **Как используется стек для обеспечения взаимодействия между вызывающей и вызываемой процедурами?**  
   Стек используется для: сохранения адреса возврата; передачи параметров; сохранения значений регистров, которые должны быть восстановлены после вызова; выделения памяти для локальных переменных.

4. **Каково назначение операнда в команде ret?**  
   Операнд в команде `ret N` указывает количество байт, которые нужно дополнительно извлечь из стека после извлечения адреса возврата. Это используется для очистки стека от параметров, переданных в подпрограмму.

5. **Для чего нужен отладчик?**  
   Отладчик позволяет: контролировать выполнение программы; устанавливать точки останова; анализировать значения регистров и памяти; изменять данные во время выполнения; находить и исправлять ошибки.

6. **Объясните назначение отладочной информации и как нужно компилировать программу, чтобы в ней присутствовала отладочная информация.**  
   Отладочная информация связывает исполняемый код с исходным текстом программы. Для ее включения нужно компилировать программу с ключом `-g`: `nasm -f elf -g program.asm`.

7. **Расшифруйте и объясните следующие термины: breakpoint, watchpoint, checkpoint, catchpoint и call stack.**  
   - **Breakpoint**: точка останова - остановка при достижении определенной строки/адреса
   - **Watchpoint**: точка наблюдения - остановка при изменении значения переменной
   - **Catchpoint**: точка перехвата - остановка при возникновении определенного события
   - **Call stack**: стек вызовов - показывает цепочку вызовов подпрограмм

8. **Назовите основные команды отладчика gdb и как они могут быть использованы для отладки программ.**  
   Основные команды GDB: `run` - запуск, `break` - установка точки останова, `stepi` - шаг с заходом, `nexti` - шаг с обходом, `print` - вывод значений, `x` - examination памяти, `info registers` - просмотр регистров, `layout` - режим TUI.

# Выводы

В ходе выполнения лабораторной работы я успешно приобрел следующие навыки:

1. **Разработка подпрограмм**: Освоил создание и использование подпрограмм в ассемблере, включая вложенные вызовы и передачу параметров через регистры.

2. **Работа с отладчиком GDB**: Научился использовать основные команды GDB для отладки программ, включая установку точек останова, пошаговое выполнение и анализ состояния программы.

3. **Диагностика ошибок**: Освоил методы поиска и исправления логических ошибок с помощью отладчика, включая анализ значений регистров и памяти.

4. **Управление выполнением программы**: Научился контролировать ход выполнения программы с помощью точек останова и пошагового режима.

5. **Работа с памятью и регистрами**: Освоил команды для просмотра и модификации содержимого памяти и регистров во время выполнения программы.

6. **Анализ стека вызовов**: Научился исследовать стек вызовов и анализировать передачу параметров через стек.

**Достижение целей работы**: Все цели лабораторной работы достигнуты. Я приобрел навыки написания программ с использованием подпрограмм и освоил методы отладки с помощью GDB. Выполнение заданий для самостоятельной работы позволило закрепить полученные знания и развить навыки отладки сложных программ.
